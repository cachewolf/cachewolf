package exp;

import utils.FileBugfix;
import CacheWolf.CWPoint;
import CacheWolf.CacheHolder;
import CacheWolf.CacheSize;
import CacheWolf.CacheTerrDiff;
import CacheWolf.CacheType;
import CacheWolf.Common;
import CacheWolf.Global;
import CacheWolf.Log;
import CacheWolf.LogList;
import CacheWolf.SafeXML;

import com.stevesoft.ewe_pat.Regex;
import com.stevesoft.ewe_pat.Transformer;

import ewe.filechooser.FileChooser;
import ewe.filechooser.FileChooserBase;
import ewe.fx.Sound;
import ewe.io.BufferedWriter;
import ewe.io.File;
import ewe.io.FileBase;
import ewe.io.FileOutputStream;
import ewe.io.FileWriter;
import ewe.io.IOException;
import ewe.io.InputStream;
import ewe.io.PrintWriter;
import ewe.io.StreamReader;
import ewe.sys.Convert;
import ewe.sys.Date;
import ewe.sys.Handle;
import ewe.sys.Process;
import ewe.sys.Vm;
import ewe.ui.CheckBoxGroup;
import ewe.ui.ControlConstants;
import ewe.ui.ControlEvent;
import ewe.ui.Event;
import ewe.ui.Form;
import ewe.ui.FormBase;
import ewe.ui.MessageBox;
import ewe.ui.ProgressBarForm;
import ewe.ui.mButton;
import ewe.ui.mCheckBox;
import ewe.ui.mChoice;
import ewe.ui.mInput;
import ewe.ui.mLabel;
import ewe.util.Enumeration;
import ewe.util.Hashtable;
import ewe.util.Iterator;
import ewe.util.zip.ZipEntry;
import ewe.util.zip.ZipException;
import ewe.util.zip.ZipFile;

/**
 * experimental GPX exporter that should better handle the various tasks that
 * can be accomplished with GPX it is not yet linked to any menu, so if you want
 * to play around with it, first you have to create a menu item
 * 
 */
public class GpxExportNg {

	/** export is in compact format */
	final static int GPX_COMPACT = 0;
	/** export is PQ like */
	final static int GPX_PQLIKE = 1;
	/** export follows gc.com MyFinds format */
	final static int GPX_MYFINDSPQ = 2;
	/** name used as key when storing preferences */
	final static String expName = "GpxExportNG";
	/** string representation of true */
	final static String TRUE = "True";
	/** string representation of false */
	final static String FALSE = "False";
	/** object used to determine custom symbols and POI categories */
	private static GarminMap poiMapper;
	/** maximum number of logs to export. can be overwritten with preferences, default unlimited*/
	private int maxLogs = ewe.math.Number.INTEGER_MAX_VALUE;
	/** number of errors / warnings during export */
	private int exportErrors = 0;
	/**  */
	private String finderid;

	final static String GPXHEADER = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
			.concat("<gpx xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" version=\"1.0\" creator=\"CacheWolf\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0 http://www.groundspeak.com/cache/1/0/cache.xsd\" xmlns=\"http://www.topografix.com/GPX/1/0\">\n")
			.concat("<name>Waypoints for Cache Listings, Generated by CacheWolf</name>\n")
			.concat("<desc>This is a list of waypoints for geocaches generated by CacheWolf</desc>\n")
			.concat("<author>Various users from geocaching.com and/or opencaching.de</author>\n")
			.concat("<email>contact@cachewolf.de</email>\n")
			.concat("<url>http://www.cachewolf.de/</url>\n")
			.concat("<urlname>CacheWolf - Paperless Geocaching</urlname>\n")
			.concat("<time>@@CREATEDATE@@T00:00:00Z</time>\n")
			.concat("<keywords>cache, geocache, waypoints</keywords>\n")
	// TODO: is it worth a second loop?
	// .concat("<bounds minlat=\"50.91695\" minlon=\"6.876383\" maxlat=\"50.935183\" maxlon=\"6.918817\" />")
	;

	final static String GPXCOMPACT = "\t<wpt lat=\"@@WPLAT@@\" lon=\"@@WPLON@@\">\n"
			.concat("\t\t<time>@@CACHETIME@@T00:00:00</time>\n")
			.concat("\t\t<name>@@WPNAME@@</name>\n")
			.concat("\t\t<cmt>@@WPCMT@@</cmt>\n")
			.concat("\t\t<desc>@@WPDESC@@</desc>\n")
			.concat("\t\t<url>@@WPURL@@</url>\n")
			.concat("\t\t<urlname>@@WPURLNAME@@</urlname>\n")
			.concat("\t\t<sym>@@WPSYMBOL@@</sym>\n")
			.concat("\t\t<type>@@WPTYPE@@</type>\n");

	final static String GPXEXTENSION = "\t\t<groundspeak:cache id=\"@@CACHEID@@\" available=\"@@CACHEAVAILABLE@@\" archived=\"@@CACHEARCHIVED\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">\n"
			.concat("\t\t\t<groundspeak:name>@@CACHENAME@@</groundspeak:name>\n")
			.concat("\t\t\t<groundspeak:placed_by>@@CACHEPLACEDBY@@</groundspeak:placed_by>\n")
			.concat("\t\t\t<groundspeak:owner id=\"@@CACHEOWNERID@@\">@@CACHEOWNER@@</groundspeak:owner>\n")
			.concat("\t\t\t<groundspeak:type>@@CACHETYPE@@</groundspeak:type>\n")
			.concat("\t\t\t<groundspeak:container>@@CACHECONTAINER@@</groundspeak:container>\n")
			.concat("\t\t\t<groundspeak:difficulty>@@CACHEDIFFICULTY@@</groundspeak:difficulty>\n")
			.concat("\t\t\t<groundspeak:terrain>@@CACHETERRAIN@@</groundspeak:terrain>\n")
			.concat("\t\t\t<groundspeak:country>@@CACHECOUNTRY@@</groundspeak:country>\n")
			.concat("\t\t\t<groundspeak:state>@@CACHESTATE@@</groundspeak:state>\n")
			.concat("\t\t\t<groundspeak:short_description html=\"@@CACHEHTML@@\">@@CACHESHORTDESCRIPTION@@</groundspeak:short_description>\n")
			.concat("\t\t\t<groundspeak:long_description html=\"@@CACHEHTML@@\">@@CACHELONGDESCRIPTION@@</groundspeak:long_description>\n")
			.concat("\t\t\t<groundspeak:encoded_hints>@@CACHEHINT@@</groundspeak:encoded_hints>\n");

	final static String GPXLOG = "\t\t\t\t<groundspeak:log id=\"@@LOGID@@\">\n"
			.concat("\t\t\t\t\t<groundspeak:date>@@LOGDATE@@T00:00:00</groundspeak:date>\n")
			.concat("\t\t\t\t\t<groundspeak:type>@@LOGTYPE@@</groundspeak:type>\n")
			.concat("\t\t\t\t\t<groundspeak:finder id=\"@@LOGFINDERID@@\">@@LOGFINDER@@</groundspeak:finder>\n")
			.concat("\t\t\t\t\t<groundspeak:text encoded=\"@@LOGENCODE@@\">@@LOGTEXT@@</groundspeak:text>\n")
			.concat("\t\t\t\t</groundspeak:log>\n");

	final static String GPXTB = "\t\t\t\t<groundspeak:travelbug id=\"@@TBID@@\" ref=\"@@TBREF@@\">\n"
			.concat("\t\t\t\t\t<groundspeak:name>@@TBNAME@@</groundspeak:name>\n")
			.concat("\t\t\t\t</groundspeak:travelbug>\n");

	// FIXME: don't use this until GPX import can strip this off as well
	final static String GPXADDIINMAIN = "@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@"
			.concat("@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@")
			.concat("@@ADDILONG@@@@ADDIDELIM@@");

	private static boolean smartIds;
	private static boolean customIcons;
	private static boolean separateFiles;
	private static boolean sendToGarmin;
	private static int outType;
	private static boolean hasBitmaps;
	private static boolean hasGarminMap;
	private static boolean hasGpsbabel;
	private static String bitmapFileName;
	private static String garminMapFileName;

	public GpxExportNg() {
		garminMapFileName = FileBase.getProgramDirectory() + "/garminmap.xml";
		bitmapFileName = FileBase.getProgramDirectory() + "/GarminPOI.zip";
		
		hasGarminMap = new File(garminMapFileName).exists();
		hasBitmaps = new File(bitmapFileName).exists();
		hasGpsbabel = Global.getPref().gpsbabel != null;
		
		finderid = Global.getPref().gcMemberId;
		if (finderid.equals("")) Global.getPref().log("GPX Export: warning gcmemberid not set, check pref.xml");
	}

	public void doit() {
		GpxExportNgForm exportOptions;
		int ret;

		exportOptions = new GpxExportNgForm(hasGarminMap, hasBitmaps, hasGpsbabel);
		ret = exportOptions.execute();

		if (FormBase.IDCANCEL == ret) {
			return;
		}

		outType = exportOptions.getExportType();
		smartIds = exportOptions.getSmartIds();
		separateFiles = exportOptions.getSeparateFiles();
		sendToGarmin = exportOptions.getSendToGarmin();
		customIcons = exportOptions.getCustomIcons();

		if (separateFiles) {
			final Hashtable fileHandles = new Hashtable();
			final String outDir;
			final String tempDir;
			final String baseDir = FileBase.getProgramDirectory();
			final String prefix = exportOptions.getPrefix();
			final FileChooser fc;
			ZipFile poiZip = null;

			if (sendToGarmin) {
				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, 
						Global.getPref().getExportPath(expName + "-GPI"));
			} else {
				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, 
						Global.getPref().getExportPath(expName + "-POI"));
			}

			fc.setTitle("Select target directory:");

			if (fc.execute() == FormBase.IDCANCEL)
				return;

			outDir = fc.getChosenFile().getFullPath();
			if (sendToGarmin) {
				Global.getPref().setExportPath(expName + "-GPI", outDir);
			} else {
				Global.getPref().setExportPath(expName + "-POI", outDir);
			}

			if ((new File(baseDir + "/garminmap.xml")).exists()) {
				poiMapper = new GarminMap();
				poiMapper.readGarminMap();
			} else {
				Global.getPref().log("GPX Export: unable to load garminmap.xml");
				new MessageBox("Export Error", "unable to load garminmap.xml",
						FormBase.OKB).execute();
				return;
			}

			if (sendToGarmin) {
				// FIXME: create proper tempdir
				tempDir = baseDir + FileBase.separator + "GPXExporterNG.tmp";
				new File(tempDir).mkdir();
			} else {
				tempDir = outDir;
				String tmp[] = new FileBugfix(tempDir).list(prefix + "*.gpx", ewe.io.FileBase.LIST_FILES_ONLY);
				for (int i = 0; i < tmp.length; i++) {
					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
					tmpFile.delete();
				}
				tmp = new FileBugfix(tempDir).list(prefix + "*.bmp", ewe.io.FileBase.LIST_FILES_ONLY);
				for (int i = 0; i < tmp.length; i++) {
					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
					tmpFile.delete();
				}
			}

			ProgressBarForm pbf = new ProgressBarForm();
			int poiCounter = 0;
			int poiCategories = 0;
			try {
				Handle h = new Handle();

				int expCount = 0;
				int totalCount = Global.getProfile().cacheDB.countVisible();

				pbf.showMainTask = false;
				pbf.setTask(h, "Exporting ...");
				pbf.exec();

				for (int i = 0; i < Global.getProfile().cacheDB.size(); i++) {
					CacheHolder ch = Global.getProfile().cacheDB.get(i);
					if (!ch.isVisible()) {
						continue;
					} else if (ch.is_incomplete()) {
						Global.getPref().log(
								"skipping export of incomplete waypoint "
										+ ch.getWayPoint());
					} else {
						String poiId = poiMapper.getPoiId(ch);
						if (null == poiId) {
							Global.getPref().log(
									"GPX Export: unmatched POI ID for "
											+ ch.getWayPoint() + " of type "
											+ ch.getType());
							exportErrors++;
						} else {
							PrintWriter writer;
							if (fileHandles.containsKey(poiId)) {
								writer = (PrintWriter) fileHandles.get(poiId);
							} else {
								writer = new PrintWriter(new BufferedWriter(
										new FileWriter(new File(tempDir
												+ FileBase.separator + prefix
												+ poiId + ".gpx"))));
								fileHandles.put(poiId, writer);
								writer.print(formatHeader());
							}
							writer.print(formatCache(ch));
						}

					}
					expCount++;
					h.progress = (float) expCount / (float) totalCount;
					h.changed();
				}

				try {
					poiZip = new ZipFile(FileBase.getProgramDirectory()
							+ FileBase.separator + "GarminPOI.zip");
				} catch (IOException e) {
					Global.getPref().log(
							"GPX Export: warning GarminPOI.zip not found", e,
							Global.getPref().debug);
					exportErrors++;
				}

				if (sendToGarmin) {
					String tmp[] = new FileBugfix(outDir).list(
							prefix + "*.gpi", ewe.io.FileBase.LIST_FILES_ONLY);
					for (int i = 0; i < tmp.length; i++) {
						FileBugfix tmpFile = new FileBugfix(outDir
								+ FileBase.separator + tmp[i]);
						tmpFile.delete();
					}
					pbf.exit(0);
					poiCategories=fileHandles.size();
					pbf.setTask(h, "Transfer");
					pbf.exec();
				}

				Enumeration keys = fileHandles.keys();
				while (keys.hasMoreElements()) {

					String key = (String) keys.nextElement();
					PrintWriter writer = (PrintWriter) fileHandles.get(key);

					writer.print("</gpx>\n");
					writer.close();
					if (sendToGarmin) {
						poiCounter++;
						h.progress = (float) poiCounter / (float) poiCategories;
						h.changed();
					}
					if (poiZip != null) {
						if (!copyPoiIcon(tempDir, key, prefix, poiZip)) {
							exportErrors++;
							continue;
						}

						if (sendToGarmin) {
							String[] cmdStack = new String[9];
							cmdStack[0]=Global.getPref().gpsbabel;
							cmdStack[1]="-i";
							cmdStack[2]="gpx";
							cmdStack[3]="-f";
							cmdStack[4]=tempDir + FileBase.separator + prefix + key + ".gpx";
							cmdStack[5]="-o";
							cmdStack[6]="garmin_gpi,sleep=1,category="+prefix + key+",bitmap="+tempDir + FileBase.separator + prefix + key	+ ".bmp";
							cmdStack[7]="-F";
							cmdStack[8]=outDir + FileBase.separator + prefix + key + ".gpi";
		
							Process babelProcess = startProcess(cmdStack);
							StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
							while (errorStream.isOpen()) {
								String errorMsg = errorStream.readALine();
								if (errorMsg != null) {
									Global.getPref().log("GPX Export: " + errorMsg);
									exportErrors++;
								}
								try {
									babelProcess.exitValue();
									errorStream.close();
								} catch (IllegalThreadStateException e) {
									// still running
								}
							}
						}

					}
				}

				if (sendToGarmin) {
					FileBugfix tmpdir = new FileBugfix(tempDir);
					String tmp[] = new FileBugfix(tempDir).list(prefix + "*.*",
							ewe.io.FileBase.LIST_FILES_ONLY);
					for (int i = 0; i < tmp.length; i++) {
						FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
						tmpFile.delete();
					}
					tmpdir.delete();
				}

				pbf.exit(0);

			} catch (Exception e) {
				Global.getPref().log("GPX Export: unknown cause for ", e, Global.getPref().debug);
				exportErrors++;
				pbf.exit(0);
			}
		} else {
			if (customIcons) {
				if ((new File(FileBase.getProgramDirectory() + "/garminmap.xml")).exists()) {
					poiMapper = new GarminMap();
					poiMapper.readGarminMap();
				} else {
					customIcons = false;
					Global.getPref().log("unable to load garminmap.xml");
				}
			}

			if (outType == GPX_PQLIKE) {
				maxLogs = exportOptions.getMaxLogs();
				if (maxLogs != Global.getPref().numberOfLogsToExport) {
					Global.getPref().numberOfLogsToExport = maxLogs;
					Global.getPref().dirty = true;
				}
			}
			final File file;
			if (!sendToGarmin) {
				final FileChooser fc = new FileChooser(FileChooserBase.SAVE,
						Global.getPref().getExportPath(expName + "-GPX"));

				fc.setTitle("Select target GPX file:");
				fc.addMask("*.gpx");

				if (fc.execute() == FormBase.IDCANCEL)
					return;

				file = fc.getChosenFile();
				Global.getPref()
						.setExportPath(expName + "-GPX", file.getPath());
			} else {
				file = new File("").createTempFile("gpxexport", null, null);
			}
			try {
				ProgressBarForm pbf = new ProgressBarForm();
				Handle h = new Handle();
				PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(file)));
				int expCount = 0;
				int totalCount = Global.getProfile().cacheDB.countVisible();

				outp.print(formatHeader());

				pbf.showMainTask = false;
				pbf.setTask(h, "Exporting ...");
				pbf.exec();

				for (int i = 0; i < Global.getProfile().cacheDB.size(); i++) {
					CacheHolder ch = Global.getProfile().cacheDB.get(i);
					if (!ch.isVisible()) {
						continue;
					} else if (ch.is_incomplete()) {
						exportErrors++;
						Global.getPref().log("GPX Export: skipping export of incomplete waypoint " + ch.getWayPoint());
					} else {
						outp.print(formatCache(ch));
					}
					expCount++;
					h.progress = (float) expCount / (float) totalCount;
					h.changed();
				}

				pbf.exit(0);

				outp.print("</gpx>\n");
				outp.close();
			} catch (Exception ex) {
				exportErrors++;
				if (Global.getPref().debug)
					Global.getPref().log("GPX Export: unable to write output to " + file.toString(), ex, Global.getPref().debug);
				else
					Global.getPref().log("GPX Export: unable to write output to " + file.toString());

				new MessageBox("Export Error", "unable to write output to "	+ file.toString(), FormBase.OKB).execute();
				return;
			}

			if (sendToGarmin) {
				try {
					String[] cmdStack = new String[9];
					cmdStack[0]=Global.getPref().gpsbabel;
					cmdStack[1]="-i";
					cmdStack[2]="gpx";
					cmdStack[3]="-f";
					cmdStack[4]=file.getCreationName();
					cmdStack[5]="-o";
					cmdStack[6]="garmin";
					cmdStack[7]="-F";
					cmdStack[8]=Global.getPref().garminConn.concat(":");
					
					Process babelProcess = this.startProcess(cmdStack);
					if (babelProcess != null) {
						StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
						while (errorStream.isOpen()) {
							String errorMsg = errorStream.readALine();
							if (errorMsg != null) {
								Global.getPref().log("GPX Export: " + errorMsg);
								exportErrors++;
							}
							try {
								babelProcess.exitValue();
								errorStream.close();
							} catch (IllegalThreadStateException e) {
								// still running
							}
						}
					}
				} catch (Exception ex) {
					Global.getPref().log("GPX Export error :", ex, Global.getPref().debug);
				}
				file.delete();
			}
		}
		if (exportErrors > 0) {
			new MessageBox("Export Error", exportErrors	+ " errors during export. Check log for details.",
					FormBase.OKB).execute();
		}
	}

	/**
	 * wrapper for formatting a cache. will call some subroutines to do the actual work
	 * @param ch
	 * @return
	 */
	private String formatCache(CacheHolder ch) {
		// no addis or custom in MyFindsPq - and of course only finds
		if ((GPX_MYFINDSPQ == outType) && ((ch.getType() == CacheType.CW_TYPE_CUSTOM) || ch.isAddiWpt() || !ch.is_found()))
			return "";

		if (!ch.pos.isValid())
			return "";

		StringBuffer ret = new StringBuffer();

		try {
			ret.append(formatCompact(ch));

			if (outType != GPX_COMPACT && !(ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt())) {
				ret.append(formatPqExtensions(ch));
			}

			ret.append("\t</wpt>\n");
		} catch (IllegalArgumentException e) {
			exportErrors++;
			ch.setIncomplete(true);
			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " set to incomplete ",	e, Global.getPref().debug);
			return "";
		} catch (Exception e) {
			exportErrors++;
			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " caused ", e,	Global.getPref().debug);
			return "";
		}

		return ret.toString();
	}

	/**
	 * generate minimal waypoint information according to GPX specification
	 * @param ch
	 * @return
	 */
	private String formatCompact(CacheHolder ch) {

		Transformer trans = new Transformer(true);

		trans.add(new Regex("@@WPLAT@@", String.valueOf(ch.pos.latDec).replace(',', '.')));

		trans.add(new Regex("@@WPLON@@", String.valueOf(ch.pos.lonDec).replace(',', '.')));

		if (ch.isAddiWpt()) {
			try {
				trans.add(new Regex("@@CACHETIME@@", ch.mainCache.getDateHidden()));
			} catch (Exception e) {
				Global.getPref().log(ch.getWayPoint() + " has no parent");
				trans.add(new Regex("@@CACHETIME@@", "1970-01-01"));
			}
		} else if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@CACHETIME@@", "1970-01-01"));
		} else {
			trans.add(new Regex("@@CACHETIME@@", ch.getDateHidden()));
		}

		if (smartIds && ch.getType() != CacheType.CW_TYPE_CUSTOM) {
			if (ch.isAddiWpt()) {
				trans.add(new Regex("@@WPNAME@@", SafeXML.cleanGPX(
						ch.mainCache.getWayPoint().concat(" ").concat(ch.getWayPoint().substring(0, 2)))));
			} else {
				trans.add(new Regex("@@WPNAME@@", SafeXML.cleanGPX(
						ch.getWayPoint()
						.concat(" ")
						.concat(CacheType.getExportShortId(ch.getType()))
						.concat(String.valueOf(ch.getHard()))
						.concat(String.valueOf(ch.getTerrain()))
						.concat(CacheSize.getExportShortId(ch.getCacheSize())))));
			}
		} else {
			trans.add(new Regex("@@WPNAME@@", ch.getWayPoint()));
		}

		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getFreshDetails().LongDescription)));
		} else {
			if (smartIds && outType == GPX_COMPACT) {
				if (ch.isAddiWpt()) {
					trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getCacheName() + " " + ch.getFreshDetails().LongDescription)));
				} else {
					trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getCacheName() + " " + "("+ch.getNoFindLogs()+")" + " " + Common.rot13(ch.getFreshDetails().Hints))));
				}
			} else {
				if (ch.isAddiWpt()) {
					trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getFreshDetails().LongDescription)));
				} else {
					trans.add(new Regex("\t\t<cmt>@@WPCMT@@</cmt>\n", ""));
				}
			}
		}

		if (ch.isAddiWpt()) {
			trans.add(new Regex("@@WPDESC@@", SafeXML.cleanGPX(ch.getCacheName())));
		} else {
			trans.add(new Regex("@@WPDESC@@", SafeXML.cleanGPX(
					ch.getCacheName().concat(" by ")
					.concat(ch.getCacheOwner())
					.concat(", ")
					.concat(CacheType.cw2ExportString(ch.getType()))
					.concat(" (")
					.concat(CacheTerrDiff.shortDT(ch.getHard()))
					.concat("/")
					.concat(CacheTerrDiff.shortDT(ch.getTerrain()))
					.concat(")"))));
		}

		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPURL@@", ""));
		} else {
			if (ch.isAddiWpt()) {
				// TODO: find out URL schema for additional waypoints
				// TODO: check for OC caches
				trans.add(new Regex("@@WPURL@@","http://www.geocaching.com/seek/wpt.aspx?wp=".concat(ch.getWayPoint())));
			} else {
				// TODO: check for OC caches
				trans.add(new Regex("@@WPURL@@","http://www.geocaching.com/seek/cache_details.aspx?wp=".concat(ch.getWayPoint())));
			}
		}

		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPURLNAME@@", ""));
		} else {
			trans.add(new Regex("@@WPURLNAME@@", SafeXML.cleanGPX(ch.getCacheName())));
		}

		if (customIcons) {
			trans.add(new Regex("@@WPSYMBOL@@", poiMapper.getIcon(ch)));
		} else {
			if (ch.isAddiWpt()) {
				trans.add(new Regex("@@WPSYMBOL@@", CacheType.id2GpxString(ch.getType())
						.substring(CacheType.id2GpxString(ch.getType()).indexOf("|") + 1)));
			} else if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
				trans.add(new Regex("@@WPSYMBOL@@", "Custom"));
			} else if (ch.is_found()) {
				trans.add(new Regex("@@WPSYMBOL@@", "Geocache found"));
			} else {
				trans.add(new Regex("@@WPSYMBOL@@", "Geocache"));
			}
		}

		trans.add(new Regex("@@WPTYPE@@", CacheType.id2GpxString(ch.getType())));

		return trans.replaceFirst(GPXCOMPACT);
	}

	/**
	 * format gc.com extended cache information as found in a PQ
	 * @param ch cacheholder
	 * @return formatted cache information for cache waypoints or emty string for all other waypoints (additional / custom)
	 */
	private String formatPqExtensions(CacheHolder ch) {
		// no details pq details for addis or custom waypoints
		if (ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt())
			return "";

		StringBuffer ret = new StringBuffer();
		Transformer trans = new Transformer(true);
		ch.getFreshDetails();
		trans.add(new Regex("@@CACHEID@@", ch.GetCacheID()));
		trans.add(new Regex("@@CACHEAVAILABLE@@", ch.is_available() ? TRUE : FALSE));
		trans.add(new Regex("@@CACHEARCHIVED", ch.is_archived() ? TRUE : FALSE));
		trans.add(new Regex("@@CACHENAME@@", SafeXML.cleanGPX(ch.getCacheName())));
		trans.add(new Regex("@@CACHEPLACEDBY@@", SafeXML.cleanGPX(ch.getCacheOwner())));
		trans.add(new Regex("@@CACHEOWNERID@@", "31415"));
		trans.add(new Regex("@@CACHEOWNER@@", SafeXML.cleanGPX(ch.getCacheOwner())));
		trans.add(new Regex("@@CACHETYPE@@", CacheType.id2GpxString(ch.getType())));
		trans.add(new Regex("@@CACHECONTAINER@@", CacheSize.cw2ExportString(ch.getCacheSize())));
		trans.add(new Regex("@@CACHEDIFFICULTY@@", CacheTerrDiff.shortDT(ch.getHard())));
		trans.add(new Regex("@@CACHETERRAIN@@", CacheTerrDiff.shortDT(ch.getTerrain())));
		trans.add(new Regex("@@CACHECOUNTRY@@", SafeXML.cleanGPX(ch.details.Country)));
		trans.add(new Regex("@@CACHESTATE@@", SafeXML.cleanGPX((ch.details.State))));
		trans.add(new Regex("@@CACHEHTML@@", ch.is_HTML() ? TRUE : FALSE));
		trans.add(new Regex("@@CACHESHORTDESCRIPTION@@","CacheWolf can not provide a short description"));
		trans.add(new Regex("@@CACHELONGDESCRIPTION@@", SafeXML.cleanGPX(formatLongDescription(ch))));
		trans.add(new Regex("@@CACHEHINT@@", SafeXML.cleanGPX(ch.details.Hints)));

		ret.append(trans.replaceAll(GPXEXTENSION));

		ret.append("\t\t\t<groundspeak:logs>\n");
		ret.append(formatLogs(ch));
		ret.append("\t\t\t</groundspeak:logs>\n");

		// ret.append("\t\t\t<groundspeak:travelbugs>\n");
		// ret.append(formatTbs(ch));
		// ret.append("\t\t\t</groundspeak:travelbugs>\n");

		ret.append("\t\t</groundspeak:cache>\n");
		return ret.toString();
	}

	/**
	 * format TB information as found in a gc.com GPX file
	 * @param ch cacheholder containing TB information
	 * @return
	 */
	public String formatTbs(CacheHolder ch) {
		Transformer trans = new Transformer(true);
		return "";
		// return trans.replaceFirst(GPXTB);
	}

	/**
	 * format cache logs as found in a gc.com GPX file
	 * @param ch cacheholder containing the logs
	 * @return formatted logs or empty string if no logs are present
	 */
	public String formatLogs(CacheHolder ch) {
		LogList logs = ch.getFreshDetails().CacheLogs;
		StringBuffer ret = new StringBuffer();
		String fid = "";
		
		if (outType == GPX_MYFINDSPQ) 
			fid = finderid; 

		if (0 == logs.size())
			return "";

		int exportlogs;

		if (outType == GPX_PQLIKE && maxLogs < logs.size()) {
			exportlogs = maxLogs;
		} else {
			exportlogs = logs.size();
		}

		for (int i = 0; i < exportlogs; i++) {
			String logId = "";
			Log log = logs.getLog(i);

			if (outType == GPX_MYFINDSPQ && !log.getLogger().equals(Global.getPref().myAlias))
					continue;

//			if (outType == GPX_MYFINDSPQ) 
//				logId = log.getLogId();
			
			Transformer trans = new Transformer(true);
			trans.add(new Regex("@@LOGID@@", logId));
			trans.add(new Regex("@@LOGDATE@@", log.getDate()));
			trans.add(new Regex("@@LOGTYPE@@", image2TypeText(log.getIcon())));
			trans.add(new Regex("@@LOGFINDERID@@", fid));
			trans.add(new Regex("@@LOGFINDER@@", SafeXML.cleanGPX(log.getLogger())));
			trans.add(new Regex("@@LOGENCODE@@", ""));
			trans.add(new Regex("@@LOGTEXT@@", SafeXML.cleanGPX(log.getMessage())));
			ret.append(trans.replaceAll(GPXLOG));
		}

		return ret.toString();
	}

	/**
	 * format the header of the GPX file
	 * @return
	 */
	public String formatHeader() {
		Transformer trans = new Transformer(true);
		trans.add(new Regex("@@CREATEDATE@@", new Date().setFormat("yyyy-MM-dd").toString()));
		return trans.replaceFirst(GPXHEADER);
	}

	/**
	 * format a long description as found in the gc.com GPX files
	 * @param ch cacheholder to format
	 * @return formatted output
	 */
	public String formatLongDescription(CacheHolder ch) {
		if (ch.isAddiWpt() || ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			return ch.details.LongDescription;
		} else {
			StringBuffer ret = new StringBuffer();
			String delim = "";
			ret.append(ch.details.LongDescription);
			if (ch.is_HTML()) {
				delim = "<br />";
			} else {
				delim = "\n";
			}
			// FIXME: format is not quite right yet
			// FIXME: cut Addis off in GPXimporter otherwise people who use GPX to feed CacheWolf have them doubled
			if (ch.addiWpts.size() > 0 && outType != GPX_MYFINDSPQ) {
				if (ch.is_HTML()) {
					ret.append("\n\n<p>Additional Waypoints</p>");
				} else {
					ret.append("\n\nAdditional Waypoints\n");
				}

				Iterator iter = ch.addiWpts.iterator();
				while (iter.hasNext()) {
					CacheHolder addi = (CacheHolder) iter.next();
					Transformer trans = new Transformer(true);
					trans.add(new Regex("@@ADDIID@@", addi.getWayPoint()));
					trans.add(new Regex("@@ADDISHORT@@", addi.getCacheName()));
					trans.add(new Regex("@@ADDIDELIM@@", delim));
					trans.add(new Regex("@@ADDILAT@@",formatAddiLatLon(addi.pos)));
					trans.add(new Regex("@@ADDILON@@", ""));
					trans.add(new Regex("@@ADDILONG@@",addi.getFreshDetails().LongDescription));
					ret.append(trans.replaceAll(GPXADDIINMAIN));
				}
				ret.append(delim).append("\n");
			}
			return ret.toString();
		}
	}

	public String image2TypeText(String image) {
		if (image.equals("icon_smile.gif"))
			return "Found it";
		if (image.equals("icon_sad.gif"))
			return "Didn't find it";
		if (image.equals("icon_note.gif"))
			return "Write note";
		if (image.equals("icon_enabled.gif"))
			return "Enable Listing";
		if (image.equals("icon_disabled.gif"))
			return "Temporarily Disable Listing";
		if (image.equals("icon_camera.gif"))
			return "Webcam Photo Taken";
		if (image.equals("icon_attended.gif"))
			return "Attended";
		if (image.equals("icon_greenlight.gif"))
			return "Publish Listing";
		if (image.equals("icon_rsvp.gif"))
			return "Will Attend";
		if (image.equals("big_smile.gif"))
			return "Post Reviewer Note";
		if (image.equals("traffic_cone.gif"))
			return "Archive";
		if (image.equals("icon_maint.gif"))
			return "Owner Maintenance";
		if (image.equals("icon_needsmaint.gif"))
			return "Needs Maintenance";
		if (image.equals("coord_update.gif"))
			return "Update Coordinates";
		if (image.equals("icon_remove.gif"))
			return "Needs Archived";
		Global.getPref().log("GPX Export: warning - unknown logtype " + image + " was changed to 'Write note'");
		exportErrors++;
		return "Write note";
	}

	/**
	 * create a position information suitable for a gc.com PQlike export
	 * 
	 * @param pos
	 *            position
	 * @return if position is valid return the cachewolf formatted position,
	 *         otherwise return teh string used in PQs
	 */
	private String formatAddiLatLon(CWPoint pos) {
		if (pos.isValid()) {
			return pos.toString();
		} else {
			return "N/S  __ ° __ . ___ W/E ___ ° __ . ___";
		}
	}

	/**
	 * copy the bitmap identified by <code>prefix</code> and <code>type</code> from <code>poiZip</code> to <code>outdir</code>
	 * @param outdir
	 * @param type
	 * @param prefix
	 * @param poiZip
	 * @return true on success, false otherwise
	 */
	boolean copyPoiIcon(String outdir, String type, String prefix, ZipFile poiZip) {
		ZipEntry icon;
		byte[] buff;
		int len;

		try {
			icon = poiZip.getEntry(type + ".bmp");
			if (icon == null)
				return false; // icon not found in archive

			buff = new byte[icon.getSize()];
			InputStream fis = poiZip.getInputStream(icon);
			FileOutputStream fos = new FileOutputStream(outdir
					.concat(FileBase.separator).concat(prefix).concat(type).concat(".bmp"));
			while (0 < (len = fis.read(buff)))
				fos.write(buff, 0, len);
			fos.flush();
			fos.close();
			fis.close();
		} catch (ZipException e) {
			Global.getPref().log("failed to copy icon " + type + ".bmp", e,Global.getPref().debug);
			return false;
		} catch (IOException e) {
			Global.getPref().log("failed to copy icon " + type + ".bmp", e,Global.getPref().debug);
			return false;
		}
		return true;
	}
	
	/**
	 * Execute the command defined by cmd
	 * @param cmd command and options to execute. if command or options include a space quatation marks are added. this will not wirk with the java version on unix systems
	 * @return a handle to the process on success or null otherwise
	 */
	Process startProcess(String[] cmd) {
		String command = "";
		if (cmd.length == 0) {
			exportErrors++;
			Global.getPref().log("GPX Export: empty gpsbabel command");
			return null;
		}
		
		for (int i = 0; i < cmd.length; i++) {
			if (cmd[i].indexOf(" ") > -1) {
				cmd[i]="\""+cmd[i]+"\"";
			}
			command = command.concat(cmd[i]).concat(" ");
		}
		
		try {
			return Vm.exec(command);
		} catch (IOException e) {
			Global.getPref().log("error excuting "+command, e, Global.getPref().debug);
			exportErrors++;
			return null;
		}
	}

	/**
	 * dialog to set the GPX exporter options
	 */
	private class GpxExportNgForm extends Form {
		private CheckBoxGroup cbgExportType, cbgWpName;
		private mCheckBox cbCompact, cbPqLike, cbMyFinds, cbCustomIcons,cbSeperateFiles, cbSendToGarmin, cbSmartId;
		private mCheckBox cbWpClassic, cbWpSmartId, cbWpSmartName, cbCreatePoi, cbSeperateHints;
		private mInput ibMaxLogs, ibPrefix;
		private mButton btnOk, btnCancel;
		
		private boolean hasBitmaps;
		private boolean hasGarminMap;
		private boolean hasGpsbabel;
		
		private int guiid;
		
		private mChoice chStyle, chTarget, chIds;

		/**
		 * set up the form / dialog
		 */
		public GpxExportNgForm(boolean hasGarminMap, boolean hasBitmaps, boolean hasGpsbabel) {

			guiid=0;

			this.hasBitmaps = hasBitmaps;
			this.hasGarminMap = hasGarminMap;
			this.hasGpsbabel = hasGpsbabel;
			
			// TODO: get/set defaults from profile

			this.setTitle("GPX Export");
			this.resizable = false;
			
			btnOk = new mButton("OK");
			btnCancel = new mButton("Cancel");
			
			if (guiid == 0) {
                cbgExportType = new CheckBoxGroup();

                cbCompact = new mCheckBox("Compact");
                cbCompact.setGroup(cbgExportType);

                cbPqLike = new mCheckBox("PQ like");
                cbPqLike.setGroup(cbgExportType);

                cbMyFinds = new mCheckBox("MyFinds");
                cbMyFinds.setGroup(cbgExportType);

                cbgExportType.setText("Compact");

                cbCustomIcons = new mCheckBox("custom icons");

                cbSeperateFiles = new mCheckBox("one file per type");

                cbSendToGarmin = new mCheckBox("send to Garmin GPSr");
                if (Global.getPref().gpsbabel == null)
                        cbSendToGarmin.modify(ControlConstants.Disabled, 0);

                cbSmartId = new mCheckBox("use smart IDs");

                ibPrefix = new mInput("GC-");
                ibPrefix.modify(ControlConstants.Disabled, 0);
                ibMaxLogs = new mInput(String
                                .valueOf(Global.getPref().numberOfLogsToExport));
                ibMaxLogs.modify(ControlConstants.Disabled, 0);

                addNext(cbCustomIcons);
                addLast(cbCompact);
                addNext(cbSeperateFiles);
                addLast(cbPqLike);
                addNext(cbSendToGarmin);
                addLast(cbMyFinds);
                
                addLast(cbSmartId);
                addNext(new mLabel("Prefix"));
                addLast(new mLabel("Max Logs"));

                addNext(ibPrefix);
                addLast(ibMaxLogs);

                addButton(btnOk);
                addButton(btnCancel);

			} else if (guiid == 2) {
				
				chIds = new mChoice();
				chIds.addItem("Classic IDs");
				chIds.addItem("Smart IDs");
				chIds.addItem("Smart Names");
				chIds.select(0);
				
				chStyle = new mChoice();
				chStyle.addItem("Compact");
				chStyle.addItem("PQ like");
				chStyle.addItem("MyFinds");
				chStyle.select(0);
				
				chTarget = new mChoice();
				chTarget.addItem("Single GPX");
				chTarget.addItem("Separate GPX");
				chTarget.addItem("POI");
				chTarget.select(0);
				
				ibPrefix = new mInput("GC-");
				ibPrefix.modify(ControlConstants.Disabled, 0);
				ibMaxLogs = new mInput(String
						.valueOf(Global.getPref().numberOfLogsToExport));
				ibMaxLogs.modify(ControlConstants.Disabled, 0);
				
				cbSeperateHints = new mCheckBox("Separate Hints");
				cbSendToGarmin = new mCheckBox("send to Garmin");
				cbCustomIcons = new mCheckBox("Custom Icons");

				
				addNext(new mLabel("Style"));
				addLast(chStyle);
				addNext(new mLabel("Names"));
				addLast(chIds);
				addNext(new mLabel("Target"));
				addLast(chTarget);
				addNext(cbCustomIcons);
				addLast(cbSendToGarmin);
				addLast(cbSeperateHints);
				
                addNext(new mLabel("Prefix"));
                addLast(ibPrefix);
                addNext(new mLabel("Max Logs"));
                addLast(ibMaxLogs);
				
			}
			
			addButton(btnOk);
			addButton(btnCancel);

		}

		/**
		 * react to GUI events and toogle access to the checkboxes according to
		 * radio button settings pass everything else to <code>super()</code>
		 */
		public void onEvent(Event ev) {
			if (guiid == 0) {
				if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
	
					if (ev.target == cbgExportType) {
						if (cbgExportType.getSelected() == cbCompact) {
							if (cbCustomIcons.change(0, ControlConstants.Disabled))
								cbCustomIcons.repaint();
							if (cbSeperateFiles.change(0, ControlConstants.Disabled))
								cbSeperateFiles.repaint();
							if (Global.getPref().gpsbabel != null)
								if (cbSendToGarmin.change(0, ControlConstants.Disabled))
									cbSendToGarmin.repaint();
							if (cbSmartId.change(0, ControlConstants.Disabled))
								cbSmartId.repaint();
							if (ibMaxLogs.change(ControlConstants.Disabled, 0))
								ibMaxLogs.repaint();
						} else if (cbgExportType.getSelected() == cbPqLike) {
							cbSeperateFiles.setState(false);
							if (cbCustomIcons.change(0, ControlConstants.Disabled))
								cbCustomIcons.repaint();
							if (cbSeperateFiles.change(ControlConstants.Disabled, 0))
								cbSeperateFiles.repaint();
							if (Global.getPref().gpsbabel != null)
								if (cbSendToGarmin.change(0, ControlConstants.Disabled))
									cbSendToGarmin.repaint();
							if (cbSmartId.change(0, ControlConstants.Disabled))
								cbSmartId.repaint();
							if (ibPrefix.change(ControlConstants.Disabled, 0))
								ibPrefix.repaint();
							if (ibMaxLogs.change(ControlConstants.Disabled, 1))
								ibMaxLogs.repaint();
						} else if (cbgExportType.getSelected() == cbMyFinds) {
							cbCustomIcons.setState(false);
							cbSeperateFiles.setState(false);
							cbSendToGarmin.setState(false);
							cbSmartId.setState(false);
							if (cbCustomIcons.change(ControlConstants.Disabled, 0))
								cbCustomIcons.repaint();
							if (cbSeperateFiles.change(ControlConstants.Disabled, 0))
								cbSeperateFiles.repaint();
							if (cbSendToGarmin.change(ControlConstants.Disabled, 0))
								cbSendToGarmin.repaint();
							if (cbSmartId.change(ControlConstants.Disabled, 0))
								cbSmartId.repaint();
							if (ibPrefix.change(ControlConstants.Disabled, 0))
								ibPrefix.repaint();
							if (ibMaxLogs.change(ControlConstants.Disabled, 0))
								ibMaxLogs.repaint();
						}
					} else if (ev.target == cbSeperateFiles) {
						if (cbSeperateFiles.state) {
							if (ibPrefix.change(ControlConstants.Disabled, 1))
								ibPrefix.repaint();
						} else {
							if (ibPrefix.change(ControlConstants.Disabled, 0))
								ibPrefix.repaint();
						}
					} else if (ev.target == btnOk) {
						if (cbPqLike.state) {
							try {
								int logs = getMaxLogs();
								if (logs > -1) {
									close(1);
								} else {
									ibMaxLogs.selectAll();
									ibMaxLogs.takeFocus(0);
									Sound.beep();
								}
							} catch (NumberFormatException e) {
								ibMaxLogs.selectAll();
								ibMaxLogs.takeFocus(0);
								Sound.beep();
							}
						} else {
							close(1);
						}
	
					} else if (ev.target == btnCancel) {
						close(-1);
					}
				}
			} else if (guiid == 2) {
				
			}
			super.onEvent(ev);
		}

		/**
		 * get the export type the user selected
		 * 
		 * @return index of selected option in checkboxgroup
		 * @see GpxExportNg
		 */
		public int getExportType() {
			return cbgExportType.getSelectedIndex();
		}

		/**
		 * check if the user wants smart IDs
		 * 
		 * @return true for smart IDs, false otherwise
		 */
		public boolean getSmartIds() {
			return cbSmartId.state;
		}

		/**
		 * check if user wants to send output straight to a Garmin GPSr
		 * 
		 * @return true for GPSr transfer, false otherwise
		 */
		public boolean getSendToGarmin() {
			return cbSendToGarmin.state;
		}

		/**
		 * check if user wants custom icons
		 * 
		 * @return true if user wants custom icons, false otherwise
		 */
		public boolean getCustomIcons() {
			return cbCustomIcons.state;
		}

		/**
		 * check if user wants separate files (POI loader)
		 * 
		 * @return true for separate files, false for single file
		 */
		public boolean getSeparateFiles() {
			return cbSeperateFiles.state;
		}

		/**
		 * get the number of logs to export. used in PQlike export.
		 * 
		 * @return number of logs to export
		 */
		public int getMaxLogs() {
			return Convert.parseInt(ibMaxLogs.getText());
		}

		/**
		 * get prefix for sepearte file export
		 * 
		 * @return prefix for separate file export
		 */
		public String getPrefix() {
			return ibPrefix.getText();
		}
	}
}
