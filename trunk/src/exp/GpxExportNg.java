package exp;

import utils.FileBugfix;
import CacheWolf.CWPoint;
import CacheWolf.CacheHolder;
import CacheWolf.CacheSize;
import CacheWolf.CacheTerrDiff;
import CacheWolf.CacheType;
import CacheWolf.Common;
import CacheWolf.Global;
import CacheWolf.Log;
import CacheWolf.LogList;
import CacheWolf.SafeXML;

import com.stevesoft.ewe_pat.Regex;
import com.stevesoft.ewe_pat.Transformer;

import ewe.filechooser.FileChooser;
import ewe.filechooser.FileChooserBase;
import ewe.fx.Sound;
import ewe.io.BufferedWriter;
import ewe.io.File;
import ewe.io.FileBase;
import ewe.io.FileOutputStream;
import ewe.io.FileWriter;
import ewe.io.IOException;
import ewe.io.InputStream;
import ewe.io.PrintWriter;
import ewe.io.StreamReader;
import ewe.sys.Convert;
import ewe.sys.Date;
import ewe.sys.Handle;
import ewe.sys.Process;
import ewe.sys.Vm;
import ewe.ui.CheckBoxGroup;
import ewe.ui.ControlConstants;
import ewe.ui.ControlEvent;
import ewe.ui.Event;
import ewe.ui.Form;
import ewe.ui.FormBase;
import ewe.ui.MessageBox;
import ewe.ui.ProgressBarForm;
import ewe.ui.mButton;
import ewe.ui.mCheckBox;
import ewe.ui.mInput;
import ewe.ui.mLabel;
import ewe.util.Enumeration;
import ewe.util.Hashtable;
import ewe.util.Iterator;
import ewe.util.zip.ZipEntry;
import ewe.util.zip.ZipException;
import ewe.util.zip.ZipFile;

/**
 * experimental GPX exporter that should better handle the various tasks that
 * can be accomplished with GPX it is not yet linked to any menu, so if you want
 * to play around with it, first you have to create a menu item
 * 
 */
public class GpxExportNg {

	/** export is in compact format */
	final static int GPX_COMPACT = 0;
	/** export is PQ like */
	final static int GPX_PQLIKE = 1;
	/** export follows gc.com myfinds format */
	final static int GPX_MYFINDSPQ = 2;

	final static String expName = "GpxExportNG";
	final static String TRUE = "True";
	final static String FALSE = "False";
	private static GarminMap poiMapper;
	private int maxLogs = ewe.math.Number.INTEGER_MAX_VALUE;
	private int exportErrors = 0;

	final static String GPXHEADER = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
			.concat("<gpx xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" version=\"1.0\" creator=\"CacheWolf\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0 http://www.groundspeak.com/cache/1/0/cache.xsd\" xmlns=\"http://www.topografix.com/GPX/1/0\">\n")
			.concat("<name>Waypoints for Cache Listings, Generated by CacheWolf</name>\n")
			.concat("<desc>This is a list of waypoints for geocaches generated by CacheWolf</desc>\n")
			.concat("<author>Various users from geocaching.com and/or opencaching.de</author>\n")
			.concat("<email>contact@cachewolf.de</email>\n")
			.concat("<url>http://www.cachewolf.de/</url>\n")
			.concat("<urlname>CacheWolf - Paperless Geocaching</urlname>\n")
			.concat("<time>@@CREATEDATE@@T00:00:00Z</time>\n")
			.concat("<keywords>cache, geocache, waypoints</keywords>\n")
	// TODO: is it worth a second loop?
	// .concat("<bounds minlat=\"50.91695\" minlon=\"6.876383\" maxlat=\"50.935183\" maxlon=\"6.918817\" />")
	;

	final static String GPXCOMPACT = "\t<wpt lat=\"@@WPLAT@@\" lon=\"@@WPLON@@\">\n"
			.concat("\t\t<time>@@CACHETIME@@T00:00:00</time>\n")
			.concat("\t\t<name>@@WPNAME@@</name>\n")
			.concat("\t\t<cmt>@@WPCMT@@</cmt>\n")
			.concat("\t\t<desc>@@WPDESC@@</desc>\n")
			.concat("\t\t<url>@@WPURL@@</url>\n")
			.concat("\t\t<urlname>@@WPURLNAME@@</urlname>\n")
			.concat("\t\t<sym>@@WPSYMBOL@@</sym>\n")
			.concat("\t\t<type>@@WPTYPE@@</type>\n");

	final static String GPXEXTENSION = "\t\t<groundspeak:cache id=\"@@CACHEID@@\" available=\"@@CACHEAVAILABLE@@\" archived=\"@@CACHEARCHIVED\" xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0\">\n"
			.concat("\t\t\t<groundspeak:name>@@CACHENAME@@</groundspeak:name>\n")
			.concat("\t\t\t<groundspeak:placed_by>@@CACHEPLACEDBY@@</groundspeak:placed_by>\n")
			.concat("\t\t\t<groundspeak:owner id=\"@@CACHEOWNERID@@\">@@CACHEOWNER@@</groundspeak:owner>\n")
			.concat("\t\t\t<groundspeak:type>@@CACHETYPE@@</groundspeak:type>\n")
			.concat("\t\t\t<groundspeak:container>@@CACHECONTAINER@@</groundspeak:container>\n")
			.concat("\t\t\t<groundspeak:difficulty>@@CACHEDIFFICULTY@@</groundspeak:difficulty>\n")
			.concat("\t\t\t<groundspeak:terrain>@@CACHETERRAIN@@</groundspeak:terrain>\n")
			.concat("\t\t\t<groundspeak:country>@@CACHECOUNTRY@@</groundspeak:country>\n")
			.concat("\t\t\t<groundspeak:state>@@CACHESTATE@@</groundspeak:state>\n")
			.concat("\t\t\t<groundspeak:short_description html=\"@@CACHEHTML@@\">@@CACHESHORTDESCRIPTION@@</groundspeak:short_description>\n")
			.concat("\t\t\t<groundspeak:long_description html=\"@@CACHEHTML@@\">@@CACHELONGDESCRIPTION@@</groundspeak:long_description>\n")
			.concat("\t\t\t<groundspeak:encoded_hints>@@CACHEHINT@@</groundspeak:encoded_hints>\n");

	final static String GPXLOG = "\t\t\t\t<groundspeak:log id=\"@@LOGID@@\">\n"
			.concat("\t\t\t\t\t<groundspeak:date>@@LOGDATE@@T00:00:00</groundspeak:date>\n")
			.concat("\t\t\t\t\t<groundspeak:type>@@LOGTYPE@@</groundspeak:type>\n")
			.concat("\t\t\t\t\t<groundspeak:finder id=\"@@LOGFINDERID@@\">@@LOGFINDER@@</groundspeak:finder>\n")
			.concat("\t\t\t\t\t<groundspeak:text encoded=\"@@LOGENCODE@@\">@@LOGTEXT@@</groundspeak:text>\n")
			.concat("\t\t\t\t</groundspeak:log>\n");

	final static String GPXTB = "\t\t\t\t<groundspeak:travelbug id=\"@@TBID@@\" ref=\"@@TBREF@@\">\n"
			.concat("\t\t\t\t\t<groundspeak:name>@@TBNAME@@</groundspeak:name>\n")
			.concat("\t\t\t\t</groundspeak:travelbug>\n");

	// FIXME: don't use this until GPX import can strip this off as well
	final static String GPXADDIINMAIN = "@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@"
			.concat("@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@")
			.concat("@@ADDILONG@@@@ADDIDELIM@@");

	static boolean smartIds;
	static boolean customIcons;
	static boolean separateFiles;
	static boolean sendToGarmin;
	static int outType;

	public GpxExportNg() {
		// do nothing
	}

	public void doit() {
		GpxExportNgForm exportOptions;
		int ret;

		exportOptions = new GpxExportNgForm();
		ret = exportOptions.execute();

		if (FormBase.IDCANCEL == ret) {
			return;
		}

		outType = exportOptions.getExportType();
		smartIds = exportOptions.getSmartIds();
		separateFiles = exportOptions.getSeparateFiles();
		sendToGarmin = exportOptions.getSendToGarmin();
		customIcons = exportOptions.getCustomIcons();

		if (separateFiles) {
			final Hashtable fileHandles = new Hashtable();
			final String outDir;
			final String tempDir;
			final String baseDir = FileBase.getProgramDirectory();
			final String prefix = exportOptions.getPrefix();
			final FileChooser fc;
			ZipFile poiZip = null;

			if (sendToGarmin) {
				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, 
						Global.getPref().getExportPath(expName + "-GPI"));
			} else {
				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, 
						Global.getPref().getExportPath(expName + "-POI"));
			}

			fc.setTitle("Select target directory:");

			if (fc.execute() == FormBase.IDCANCEL)
				return;

			outDir = fc.getChosenFile().getFullPath();
			if (sendToGarmin) {
				Global.getPref().setExportPath(expName + "-GPI", outDir);
			} else {
				Global.getPref().setExportPath(expName + "-POI", outDir);
			}

			if ((new File(baseDir + "/garminmap.xml")).exists()) {
				poiMapper = new GarminMap();
				poiMapper.readGarminMap();
			} else {
				Global.getPref().log("GPX Export: unable to load garminmap.xml");
				new MessageBox("Export Error", "unable to load garminmap.xml",
						FormBase.OKB).execute();
				return;
			}

			if (sendToGarmin) {
				// FIXME: create proper tempdir
				tempDir = baseDir + FileBase.separator + "GPXExporterNG.tmp";
				new File(tempDir).mkdir();
			} else {
				tempDir = outDir;
				String tmp[] = new FileBugfix(tempDir).list(prefix + "*.gpx",
						ewe.io.FileBase.LIST_FILES_ONLY);
				for (int i = 0; i < tmp.length; i++) {
					FileBugfix tmpFile = new FileBugfix(tempDir
							+ FileBase.separator + tmp[i]);
					tmpFile.delete();
				}
				tmp = new FileBugfix(tempDir).list(prefix + "*.bmp",
						ewe.io.FileBase.LIST_FILES_ONLY);
				for (int i = 0; i < tmp.length; i++) {
					FileBugfix tmpFile = new FileBugfix(tempDir
							+ FileBase.separator + tmp[i]);
					tmpFile.delete();
				}
			}

			ProgressBarForm pbf = new ProgressBarForm();
			try {
				Handle h = new Handle();

				int expCount = 0;
				int totalCount = Global.getProfile().cacheDB.countVisible();

				pbf.showMainTask = false;
				pbf.setTask(h, "Exporting ...");
				pbf.exec();

				for (int i = 0; i < Global.getProfile().cacheDB.size(); i++) {
					CacheHolder ch = Global.getProfile().cacheDB.get(i);
					if (!ch.isVisible()) {
						continue;
					} else if (ch.is_incomplete()) {
						Global.getPref().log(
								"skipping export of incomplete waypoint "
										+ ch.getWayPoint());
					} else {
						String poiId = poiMapper.getPoiId(ch);
						if (null == poiId) {
							Global.getPref().log(
									"GPX Export: unmatched POI ID for "
											+ ch.getWayPoint() + " of type "
											+ ch.getType());
							exportErrors++;
						} else {
							PrintWriter writer;
							if (fileHandles.containsKey(poiId)) {
								writer = (PrintWriter) fileHandles.get(poiId);
							} else {
								writer = new PrintWriter(new BufferedWriter(
										new FileWriter(new File(tempDir
												+ FileBase.separator + prefix
												+ poiId + ".gpx"))));
								fileHandles.put(poiId, writer);
								writer.print(formatHeader());
							}
							writer.print(formatCache(ch));
						}

					}
					expCount++;
					h.progress = (float) expCount / (float) totalCount;
					h.changed();
				}

				try {
					poiZip = new ZipFile(FileBase.getProgramDirectory()
							+ FileBase.separator + "GarminPOI.zip");
				} catch (IOException e) {
					Global.getPref().log(
							"GPX Export: warning GarminPOI.zip not found", e,
							Global.getPref().debug);
					exportErrors++;
				}

				if (sendToGarmin) {
					String tmp[] = new FileBugfix(outDir).list(
							prefix + "*.gpi", ewe.io.FileBase.LIST_FILES_ONLY);
					for (int i = 0; i < tmp.length; i++) {
						FileBugfix tmpFile = new FileBugfix(outDir
								+ FileBase.separator + tmp[i]);
						tmpFile.delete();
					}
				}

				Enumeration keys = fileHandles.keys();
				while (keys.hasMoreElements()) {

					String key = (String) keys.nextElement();
					PrintWriter writer = (PrintWriter) fileHandles.get(key);

					writer.print("</gpx>\n");
					writer.close();
					if (poiZip != null)
						if (!copyPoiIcon(tempDir, key, prefix, poiZip))
							exportErrors++;

					// TODO: check with blanks and on windows
					String gpsBabelCommand = Global.getPref().gpsbabel
							.concat(" -i gpx -f ")
							.concat(tempDir + FileBase.separator + prefix + key + ".gpx")
							.concat(" -o garmin_gpi,sleep=1,category=\"")
							.concat(prefix + key).concat("\",bitmap=")
							.concat(tempDir + FileBase.separator + prefix + key	+ ".bmp")
							.concat(" -F ")
							.concat(outDir + FileBase.separator + prefix + key + ".gpi");

					if (Global.getPref().debug)
						Global.getPref().log(gpsBabelCommand);

					Process babelProcess = Vm.exec(gpsBabelCommand);
					StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
					while (errorStream.isOpen()) {
						String errorMsg = errorStream.readALine();
						if (errorMsg != null) {
							Global.getPref().log("GPX Export: " + errorMsg);
							exportErrors++;
						}
						try {
							babelProcess.exitValue();
							errorStream.close();
						} catch (IllegalThreadStateException e) {
							// still running
						}
					}
				}

				if (sendToGarmin) {
					FileBugfix tmpdir = new FileBugfix(tempDir);
					String tmp[] = new FileBugfix(tempDir).list(prefix + "*.*",
							ewe.io.FileBase.LIST_FILES_ONLY);
					for (int i = 0; i < tmp.length; i++) {
						FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
						tmpFile.delete();
					}
					tmpdir.delete();
				}

				pbf.exit(0);

			} catch (Exception e) {
				Global.getPref().log("GPX Export: unknown cause for ", e, Global.getPref().debug);
				exportErrors++;
				pbf.exit(0);
			}
		} else {
			if (customIcons) {
				if ((new File(FileBase.getProgramDirectory() + "/garminmap.xml")).exists()) {
					poiMapper = new GarminMap();
					poiMapper.readGarminMap();
				} else {
					customIcons = false;
					Global.getPref().log("unable to load garminmap.xml");
				}
			}

			if (outType == GPX_PQLIKE) {
				maxLogs = exportOptions.getMaxLogs();
				if (maxLogs != Global.getPref().numberOfLogsToExport) {
					Global.getPref().numberOfLogsToExport = maxLogs;
					Global.getPref().dirty = true;
				}
			}
			final File file;
			if (!sendToGarmin) {
				final FileChooser fc = new FileChooser(FileChooserBase.SAVE,
						Global.getPref().getExportPath(expName + "-GPX"));

				fc.setTitle("Select target GPX file:");
				fc.addMask("*.gpx");

				if (fc.execute() == FormBase.IDCANCEL)
					return;

				file = fc.getChosenFile();
				Global.getPref()
						.setExportPath(expName + "-GPX", file.getPath());
			} else {
				file = new File("").createTempFile("gpxexport", null, null);
			}
			try {
				ProgressBarForm pbf = new ProgressBarForm();
				Handle h = new Handle();
				PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(file)));
				int expCount = 0;
				int totalCount = Global.getProfile().cacheDB.countVisible();

				outp.print(formatHeader());

				pbf.showMainTask = false;
				pbf.setTask(h, "Exporting ...");
				pbf.exec();

				for (int i = 0; i < Global.getProfile().cacheDB.size(); i++) {
					CacheHolder ch = Global.getProfile().cacheDB.get(i);
					if (!ch.isVisible()) {
						continue;
					} else if (ch.is_incomplete()) {
						exportErrors++;
						Global.getPref().log("GPX Export: skipping export of incomplete waypoint " + ch.getWayPoint());
					} else {
						outp.print(formatCache(ch));
					}
					expCount++;
					h.progress = (float) expCount / (float) totalCount;
					h.changed();
				}

				pbf.exit(0);

				outp.print("</gpx>\n");
				outp.close();
			} catch (Exception ex) {
				exportErrors++;
				if (Global.getPref().debug)
					Global.getPref().log("GPX Export: unable to write output to " + file.toString(), ex, Global.getPref().debug);
				else
					Global.getPref().log("GPX Export: unable to write output to " + file.toString());

				new MessageBox("Export Error", "unable to write output to "	+ file.toString(), FormBase.OKB).execute();
				return;
			}

			if (sendToGarmin) {
				try {
					String gpsBabelCommand;
					gpsBabelCommand = Global.getPref().gpsbabel
						.concat(" ")
						.concat(Global.getPref().garminGPSBabelOptions)
						.concat(" -i gpx -f ")
						.concat(file.getCreationName())
						.concat(" -o garmin -F ")
						.concat(Global.getPref().garminConn)
						.concat(":");
					if (Global.getPref().debug)
						Global.getPref().log("GPX Export: gpsbabelcommand is "+ gpsBabelCommand);
					
					Process babelProcess = Vm.exec(gpsBabelCommand);
					StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
					while (errorStream.isOpen()) {
						String errorMsg = errorStream.readALine();
						if (errorMsg != null) {
							Global.getPref().log("GPX Export: " + errorMsg);
							exportErrors++;
						}
						try {
							babelProcess.exitValue();
							errorStream.close();
						} catch (IllegalThreadStateException e) {
							// still running
						}
					}
				} catch (Exception ex) {
					Global.getPref().log("GPX Export error :", ex, Global.getPref().debug);
				}
				file.delete();
			}
		}
		if (exportErrors > 0) {
			new MessageBox("Export Error", exportErrors	+ " errors during export. Check log for details.",
					FormBase.OKB).execute();
		}
	}

	private String formatCache(CacheHolder ch) {
		// no addis or custom in MyFindsPq - and of course only finds
		if ((GPX_MYFINDSPQ == outType) && ((ch.getType() == CacheType.CW_TYPE_CUSTOM) || ch.isAddiWpt() || !ch.is_found()))
			return "";

		if (!ch.pos.isValid())
			return "";

		StringBuffer ret = new StringBuffer();

		try {
			ret.append(formatCompact(ch));

			if (outType != GPX_COMPACT && !(ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt())) {
				ret.append(formatPqExtensions(ch));
			}

			ret.append("\t</wpt>\n");
		} catch (IllegalArgumentException e) {
			exportErrors++;
			ch.setIncomplete(true);
			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " set to incomplete ",	e, Global.getPref().debug);
			return "";
		} catch (Exception e) {
			exportErrors++;
			Global.getPref().log("GPX Export: " + ch.getWayPoint() + " caused ", e,	Global.getPref().debug);
			return "";
		}

		return ret.toString();
	}

	private String formatCompact(CacheHolder ch) {

		Transformer trans = new Transformer(true);

		trans.add(new Regex("@@WPLAT@@", String.valueOf(ch.pos.latDec).replace(',', '.')));

		trans.add(new Regex("@@WPLON@@", String.valueOf(ch.pos.lonDec).replace(',', '.')));

		if (ch.isAddiWpt()) {
			try {
				trans.add(new Regex("@@CACHETIME@@", ch.mainCache.getDateHidden()));
			} catch (Exception e) {
				Global.getPref().log(ch.getWayPoint() + " has no parent");
				trans.add(new Regex("@@CACHETIME@@", "1970-01-01"));
			}
		} else if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@CACHETIME@@", "1970-01-01"));
		} else {
			trans.add(new Regex("@@CACHETIME@@", ch.getDateHidden()));
		}

		if (smartIds && ch.getType() != CacheType.CW_TYPE_CUSTOM) {
			if (ch.isAddiWpt()) {
				trans.add(new Regex("@@WPNAME@@", SafeXML.cleanGPX(
						ch.mainCache.getWayPoint().concat(" ").concat(ch.getWayPoint().substring(0, 2)))));
			} else {
				trans.add(new Regex("@@WPNAME@@", SafeXML.cleanGPX(
						ch.getWayPoint()
						.concat(" ")
						.concat(CacheType.getExportShortId(ch.getType()))
						.concat(String.valueOf(ch.getHard()))
						.concat(String.valueOf(ch.getTerrain()))
						.concat(CacheSize.getExportShortId(ch.getCacheSize())))));
			}
		} else {
			trans.add(new Regex("@@WPNAME@@", ch.getWayPoint()));
		}

		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getFreshDetails().LongDescription)));
		} else {
			if (smartIds && outType == GPX_COMPACT) {
				if (ch.isAddiWpt()) {
					trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getCacheName() + " " + ch.getFreshDetails().LongDescription)));
				} else {
					trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getCacheName() + " " + Common.rot13(ch.getFreshDetails().Hints))));
				}
			} else {
				if (ch.isAddiWpt()) {
					trans.add(new Regex("@@WPCMT@@", SafeXML.cleanGPX(ch.getFreshDetails().LongDescription)));
				} else {
					trans.add(new Regex("\t\t<cmt>@@WPCMT@@</cmt>\n", ""));
				}
			}
		}

		if (ch.isAddiWpt()) {
			trans.add(new Regex("@@WPDESC@@", SafeXML.cleanGPX(ch.getCacheName())));
		} else {
			trans.add(new Regex("@@WPDESC@@", SafeXML.cleanGPX(
					ch.getCacheName().concat(" by ")
					.concat(ch.getCacheOwner())
					.concat(", ")
					.concat(CacheType.cw2ExportString(ch.getType()))
					.concat(" (")
					.concat(CacheTerrDiff.shortDT(ch.getHard()))
					.concat("/")
					.concat(CacheTerrDiff.shortDT(ch.getTerrain()))
					.concat(")"))));
		}

		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPURL@@", ""));
		} else {
			if (ch.isAddiWpt()) {
				// TODO: find out URL schema for additional waypoints
				// TODO: check for OC caches
				trans.add(new Regex("@@WPURL@@","http://www.geocaching.com/seek/wpt.aspx?wp=".concat(ch.getWayPoint())));
			} else {
				// TODO: check for OC caches
				trans.add(new Regex("@@WPURL@@","http://www.geocaching.com/seek/cache_details.aspx?wp=".concat(ch.getWayPoint())));
			}
		}

		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPURLNAME@@", ""));
		} else {
			trans.add(new Regex("@@WPURLNAME@@", SafeXML.cleanGPX(ch.getCacheName())));
		}

		if (customIcons) {
			trans.add(new Regex("@@WPSYMBOL@@", poiMapper.getIcon(ch)));
		} else {
			if (ch.isAddiWpt()) {
				trans.add(new Regex("@@WPSYMBOL@@", CacheType.id2GpxString(ch.getType())
						.substring(CacheType.id2GpxString(ch.getType()).indexOf("|") + 1)));
			} else if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
				trans.add(new Regex("@@WPSYMBOL@@", "Custom"));
			} else if (ch.is_found()) {
				trans.add(new Regex("@@WPSYMBOL@@", "Geocache found"));
			} else {
				trans.add(new Regex("@@WPSYMBOL@@", "Geocache"));
			}
		}

		trans.add(new Regex("@@WPTYPE@@", CacheType.id2GpxString(ch.getType())));

		return trans.replaceFirst(GPXCOMPACT);
	}

	private String formatPqExtensions(CacheHolder ch) {
		// no details pq details for addis or custom waypoints
		if (ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt())
			return "";

		StringBuffer ret = new StringBuffer();
		Transformer trans = new Transformer(true);
		ch.getFreshDetails();
		trans.add(new Regex("@@CACHEID@@", ch.GetCacheID()));
		trans.add(new Regex("@@CACHEAVAILABLE@@", ch.is_available() ? TRUE : FALSE));
		trans.add(new Regex("@@CACHEARCHIVED", ch.is_archived() ? TRUE : FALSE));
		trans.add(new Regex("@@CACHENAME@@", SafeXML.cleanGPX(ch.getCacheName())));
		trans.add(new Regex("@@CACHEPLACEDBY@@", SafeXML.cleanGPX(ch.getCacheOwner())));
		trans.add(new Regex("@@CACHEOWNERID@@", "31415"));
		trans.add(new Regex("@@CACHEOWNER@@", SafeXML.cleanGPX(ch.getCacheOwner())));
		trans.add(new Regex("@@CACHETYPE@@", CacheType.id2GpxString(ch.getType())));
		trans.add(new Regex("@@CACHECONTAINER@@", CacheSize.cw2ExportString(ch.getCacheSize())));
		trans.add(new Regex("@@CACHEDIFFICULTY@@", CacheTerrDiff.shortDT(ch.getHard())));
		trans.add(new Regex("@@CACHETERRAIN@@", CacheTerrDiff.shortDT(ch.getTerrain())));
		trans.add(new Regex("@@CACHECOUNTRY@@", SafeXML.cleanGPX(ch.details.Country)));
		trans.add(new Regex("@@CACHESTATE@@", SafeXML.cleanGPX((ch.details.State))));
		trans.add(new Regex("@@CACHEHTML@@", ch.is_HTML() ? TRUE : FALSE));
		trans.add(new Regex("@@CACHESHORTDESCRIPTION@@","CacheWolf can not provide a short description"));
		trans.add(new Regex("@@CACHELONGDESCRIPTION@@", SafeXML.cleanGPX(formatLongDescription(ch))));
		trans.add(new Regex("@@CACHEHINT@@", SafeXML.cleanGPX(ch.details.Hints)));

		ret.append(trans.replaceAll(GPXEXTENSION));

		ret.append("\t\t\t<groundspeak:logs>\n");
		ret.append(formatLogs(ch));
		ret.append("\t\t\t</groundspeak:logs>\n");

		// ret.append("\t\t\t<groundspeak:travelbugs>\n");
		// ret.append(formatTbs(ch));
		// ret.append("\t\t\t</groundspeak:travelbugs>\n");

		ret.append("\t\t</groundspeak:cache>\n");
		return ret.toString();
	}

	public String formatTbs(CacheHolder ch) {
		Transformer trans = new Transformer(true);
		return "";
		// return trans.replaceFirst(GPXTB);
	}

	public String formatLogs(CacheHolder ch) {
		LogList logs = ch.getFreshDetails().CacheLogs;
		StringBuffer ret = new StringBuffer();

		if (0 == logs.size())
			return "";

		int exportlogs;

		if (outType == GPX_PQLIKE && maxLogs < logs.size()) {
			exportlogs = maxLogs;
		} else {
			exportlogs = logs.size();
		}

		for (int i = 0; i < exportlogs; i++) {
			Log log = logs.getLog(i);

			if (outType == GPX_MYFINDSPQ
					&& !log.getLogger().equals(Global.getPref().myAlias))
				continue;

			Transformer trans = new Transformer(true);
			trans.add(new Regex("@@LOGID@@", ""));
			trans.add(new Regex("@@LOGDATE@@", log.getDate()));
			trans.add(new Regex("@@LOGTYPE@@", image2TypeText(log.getIcon())));
			trans.add(new Regex("@@LOGFINDERID@@", ""));
			trans.add(new Regex("@@LOGFINDER@@", SafeXML.cleanGPX(log.getLogger())));
			trans.add(new Regex("@@LOGENCODE@@", ""));
			trans.add(new Regex("@@LOGTEXT@@", SafeXML.cleanGPX(log.getMessage())));
			ret.append(trans.replaceAll(GPXLOG));
		}

		return ret.toString();
	}

	public String formatHeader() {
		Transformer trans = new Transformer(true);
		trans.add(new Regex("@@CREATEDATE@@", new Date().setFormat("yyyy-MM-dd").toString()));
		return trans.replaceFirst(GPXHEADER);
	}

	public String formatLongDescription(CacheHolder ch) {
		if (ch.isAddiWpt() || ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			return ch.details.LongDescription;
		} else {
			StringBuffer ret = new StringBuffer();
			String delim = "";
			ret.append(ch.details.LongDescription);
			if (ch.is_HTML()) {
				delim = "<br />";
			} else {
				delim = "\n";
			}
			// FIXME: format is not quite right yet
			// FIXME: cut Addis off in GPXimporter otherwise people who use GPX to feed CacheWolf have them doubled
			if (ch.addiWpts.size() > 0) {
				if (ch.is_HTML()) {
					ret.append("\n\n<p>Additional Waypoints</p>");
				} else {
					ret.append("\n\nAdditional Waypoints\n");
				}

				Iterator iter = ch.addiWpts.iterator();
				while (iter.hasNext()) {
					CacheHolder addi = (CacheHolder) iter.next();
					Transformer trans = new Transformer(true);
					trans.add(new Regex("@@ADDIID@@", addi.getWayPoint()));
					trans.add(new Regex("@@ADDISHORT@@", addi.getCacheName()));
					trans.add(new Regex("@@ADDIDELIM@@", delim));
					trans.add(new Regex("@@ADDILAT@@",formatAddiLatLon(addi.pos)));
					trans.add(new Regex("@@ADDILON@@", ""));
					trans.add(new Regex("@@ADDILONG@@",addi.getFreshDetails().LongDescription));
					ret.append(trans.replaceAll(GPXADDIINMAIN));
				}
				ret.append(delim).append("\n");
			}
			return ret.toString();
		}
	}

	public String image2TypeText(String image) {
		if (image.equals("icon_smile.gif"))
			return "Found it";
		if (image.equals("icon_sad.gif"))
			return "Didn't find it";
		if (image.equals("icon_note.gif"))
			return "Write note";
		if (image.equals("icon_enabled.gif"))
			return "Enable Listing";
		if (image.equals("icon_disabled.gif"))
			return "Temporarily Disable Listing";
		if (image.equals("icon_camera.gif"))
			return "Webcam Photo Taken";
		if (image.equals("icon_attended.gif"))
			return "Attended";
		if (image.equals("icon_greenlight.gif"))
			return "Publish Listing";
		if (image.equals("icon_rsvp.gif"))
			return "Will Attend";
		if (image.equals("big_smile.gif"))
			return "Post Reviewer Note";
		if (image.equals("traffic_cone.gif"))
			return "Archive";
		if (image.equals("icon_maint.gif"))
			return "Owner Maintenance";
		if (image.equals("icon_needsmaint.gif"))
			return "Needs Maintenance";
		if (image.equals("coord_update.gif"))
			return "Update Coordinates";
		if (image.equals("icon_remove.gif"))
			return "Needs Archived";
		Global.getPref().log("GPX Export: warning - unknown logtype " + image + " was changed to 'Write note'");
		exportErrors++;
		return "Write note";
	}

	/**
	 * create a position information suitable for a gc.com PQlike export
	 * 
	 * @param pos
	 *            position
	 * @return if position is valid return the cachewolf formatted position,
	 *         otherwise return teh string used in PQs
	 */
	private String formatAddiLatLon(CWPoint pos) {
		if (pos.isValid()) {
			return pos.toString();
		} else {
			return "N/S  __ ° __ . ___ W/E ___ ° __ . ___";
		}
	}

	boolean copyPoiIcon(String outdir, String type, String prefix,
			ZipFile poiZip) {
		ZipEntry icon;
		byte[] buff;
		int len;

		try {
			icon = poiZip.getEntry(type + ".bmp");
			if (icon == null)
				return false; // icon not found in archive

			buff = new byte[icon.getSize()];
			InputStream fis = poiZip.getInputStream(icon);
			FileOutputStream fos = new FileOutputStream(outdir
					.concat(FileBase.separator).concat(prefix).concat(type).concat(".bmp"));
			while (0 < (len = fis.read(buff)))
				fos.write(buff, 0, len);
			fos.flush();
			fos.close();
			fis.close();
		} catch (ZipException e) {
			Global.getPref().log("failed to copy icon " + type + ".bmp", e,Global.getPref().debug);
			return false;
		} catch (IOException e) {
			Global.getPref().log("failed to copy icon " + type + ".bmp", e,Global.getPref().debug);
			return false;
		}
		return true;
	}

	/**
	 * dialog to set the GPX exporter options
	 */
	private class GpxExportNgForm extends Form {
		private CheckBoxGroup cbgExportType;
		private mCheckBox cbCompact, cbPqLike, cbMyFinds, cbCustomIcons,cbSeperateFiles, cbSendToGarmin, cbSmartId;
		private mInput ibMaxLogs, ibPrefix;
		private mButton btnOk, btnCancel;

		/**
		 * set up the form / dialog
		 */
		public GpxExportNgForm() {
			// TODO: get/set defaults from profile

			this.setTitle("GPX Export");

			cbgExportType = new CheckBoxGroup();

			cbCompact = new mCheckBox("Compact");
			cbCompact.setGroup(cbgExportType);

			cbPqLike = new mCheckBox("PQ like");
			cbPqLike.setGroup(cbgExportType);

			cbMyFinds = new mCheckBox("MyFinds");
			cbMyFinds.setGroup(cbgExportType);

			cbgExportType.setText("Compact");

			cbCustomIcons = new mCheckBox("custom icons");

			cbSeperateFiles = new mCheckBox("one file per type");

			cbSendToGarmin = new mCheckBox("send to Garmin GPSr");
			if (Global.getPref().gpsbabel == null)
				cbSendToGarmin.modify(ControlConstants.Disabled, 0);

			cbSmartId = new mCheckBox("use smart IDs");

			ibPrefix = new mInput("GC-");
			ibPrefix.modify(ControlConstants.Disabled, 0);
			ibMaxLogs = new mInput(String
					.valueOf(Global.getPref().numberOfLogsToExport));
			ibMaxLogs.modify(ControlConstants.Disabled, 0);

			btnOk = new mButton("OK");
			btnCancel = new mButton("Cancel");

			addNext(cbCustomIcons);
			addLast(cbCompact);
			addNext(cbSeperateFiles);
			addLast(cbPqLike);
			addNext(cbSendToGarmin);
			addLast(cbMyFinds);
			addLast(cbSmartId);
			addNext(new mLabel("Prefix"));
			addLast(new mLabel("Max Logs"));

			addNext(ibPrefix);
			addLast(ibMaxLogs);

			addButton(btnOk);
			addButton(btnCancel);
		}

		/**
		 * react to GUI events and toogle access to the checkboxes according to
		 * radio button settings pass everything else to <code>super()</code>
		 */
		public void onEvent(Event ev) {
			if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {

				if (ev.target == cbgExportType) {
					if (cbgExportType.getSelected() == cbCompact) {
						if (cbCustomIcons.change(0, ControlConstants.Disabled))
							cbCustomIcons.repaint();
						if (cbSeperateFiles.change(0, ControlConstants.Disabled))
							cbSeperateFiles.repaint();
						if (Global.getPref().gpsbabel != null)
							if (cbSendToGarmin.change(0, ControlConstants.Disabled))
								cbSendToGarmin.repaint();
						if (cbSmartId.change(0, ControlConstants.Disabled))
							cbSmartId.repaint();
						if (ibMaxLogs.change(ControlConstants.Disabled, 0))
							ibMaxLogs.repaint();
					} else if (cbgExportType.getSelected() == cbPqLike) {
						cbSeperateFiles.setState(false);
						if (cbCustomIcons.change(0, ControlConstants.Disabled))
							cbCustomIcons.repaint();
						if (cbSeperateFiles.change(ControlConstants.Disabled, 0))
							cbSeperateFiles.repaint();
						if (Global.getPref().gpsbabel != null)
							if (cbSendToGarmin.change(0, ControlConstants.Disabled))
								cbSendToGarmin.repaint();
						if (cbSmartId.change(0, ControlConstants.Disabled))
							cbSmartId.repaint();
						if (ibPrefix.change(ControlConstants.Disabled, 0))
							ibPrefix.repaint();
						if (ibMaxLogs.change(ControlConstants.Disabled, 1))
							ibMaxLogs.repaint();
					} else if (cbgExportType.getSelected() == cbMyFinds) {
						cbCustomIcons.setState(false);
						cbSeperateFiles.setState(false);
						cbSendToGarmin.setState(false);
						cbSmartId.setState(false);
						if (cbCustomIcons.change(ControlConstants.Disabled, 0))
							cbCustomIcons.repaint();
						if (cbSeperateFiles.change(ControlConstants.Disabled, 0))
							cbSeperateFiles.repaint();
						if (cbSendToGarmin.change(ControlConstants.Disabled, 0))
							cbSendToGarmin.repaint();
						if (cbSmartId.change(ControlConstants.Disabled, 0))
							cbSmartId.repaint();
						if (ibPrefix.change(ControlConstants.Disabled, 0))
							ibPrefix.repaint();
						if (ibMaxLogs.change(ControlConstants.Disabled, 0))
							ibMaxLogs.repaint();
					}
				} else if (ev.target == cbSeperateFiles) {
					if (cbSeperateFiles.state) {
						if (ibPrefix.change(ControlConstants.Disabled, 1))
							ibPrefix.repaint();
					} else {
						if (ibPrefix.change(ControlConstants.Disabled, 0))
							ibPrefix.repaint();
					}
				} else if (ev.target == btnOk) {
					if (cbPqLike.state) {
						try {
							int logs = getMaxLogs();
							if (logs > -1) {
								close(1);
							} else {
								ibMaxLogs.selectAll();
								ibMaxLogs.takeFocus(0);
								Sound.beep();
							}
						} catch (NumberFormatException e) {
							ibMaxLogs.selectAll();
							ibMaxLogs.takeFocus(0);
							Sound.beep();
						}
					} else {
						close(1);
					}

				} else if (ev.target == btnCancel) {
					close(-1);
				}
			}
			super.onEvent(ev);
		}

		/**
		 * get the export type the user selected
		 * 
		 * @return index of selected option in checkboxgroup
		 * @see GpxExportNg
		 */
		public int getExportType() {
			return cbgExportType.getSelectedIndex();
		}

		/**
		 * check if the user wants smart IDs
		 * 
		 * @return true for smart IDs, false otherwise
		 */
		public boolean getSmartIds() {
			return cbSmartId.state;
		}

		/**
		 * check if user wants to send output straight to a Garmin GPSr
		 * 
		 * @return true for GPSr transfer, false otherwise
		 */
		public boolean getSendToGarmin() {
			return cbSendToGarmin.state;
		}

		/**
		 * check if user wants custom icons
		 * 
		 * @return true if user wants custom icons, false otherwise
		 */
		public boolean getCustomIcons() {
			return cbCustomIcons.state;
		}

		/**
		 * check if user wants separate files (POI loader)
		 * 
		 * @return true for separate files, false for single file
		 */
		public boolean getSeparateFiles() {
			return cbSeperateFiles.state;
		}

		/**
		 * get the number of logs to export. used in PQlike export.
		 * 
		 * @return number of logs to export
		 */
		public int getMaxLogs() {
			return Convert.parseInt(ibMaxLogs.getText());
		}

		/**
		 * get prefix for sepearte file export
		 * 
		 * @return prefix for separate file export
		 */
		public String getPrefix() {
			return ibPrefix.getText();
		}
	}
}
