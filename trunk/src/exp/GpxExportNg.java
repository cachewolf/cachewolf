package exp;

import CacheWolf.CacheHolder;
import CacheWolf.CacheSize;
import CacheWolf.CacheTerrDiff;
import CacheWolf.CacheType;
import CacheWolf.Global;

import com.stevesoft.ewe_pat.Regex;
import com.stevesoft.ewe_pat.Transformer;

import ewe.filechooser.FileChooser;
import ewe.filechooser.FileChooserBase;
import ewe.io.BufferedWriter;
import ewe.io.File;
import ewe.io.FileWriter;
import ewe.io.PrintWriter;
import ewe.sys.Date;
import ewe.sys.Vm;
import ewe.ui.FormBase;
import ewe.util.Hashtable;

//TODO: use safexml a lot more (at least start using it ;) )

/**
 * experimental GPX exporter that should better handle the various tasks that can be accomplished with GPX
 * it is not yet linked to any menu, so if you want to play around with it, first you have to create a menu item
 *
 */
public class GpxExportNg {
	
	/** export is in compact format */
	final static int GPX_COMPACT = 0;
	/** export is PQ like */
	final static int GPX_PQLIKE = 1;
	/** export follows gc.com myfinds format */
	final static int GPX_MYFINDSPQ = 2;

	final static String expName="GpxExportNG";
	final static String TRUE="True";
	final static String FALSE="False";
	
	final static String GPXHEADER = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
		.concat("<gpx xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" version=\"1.0\" creator=\"CacheWolf http://www.cachewolf.de/\" xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0 http://www.groundspeak.com/cache/1/0/cache.xsd\" xmlns=\"http://www.topografix.com/GPX/1/0\">\n")
		.concat("<name>Waypoints for Cache Listings, Generated by CacheWolf</name>\n")
		.concat("<desc>This is a list of waypoints for geocaches generated by CacheWolf</desc>\n")
		.concat("<author>Various users from geocaching.com and/or opencaching.de</author>\n")
		.concat("<email>contact@cachewolf.de</email>\n")
		.concat("<url>http://www.cachewolf.de/</url>\n")
		.concat("<urlname>CacheWolf - Paperless Geocaching</urlname>\n")
		.concat("<time>@@CREATEDATE@@T00:00:00Z</time>\n")
		.concat("<keywords>cache, geocache, waypoints</keywords>\n")
// TODO: is it worth a second loop?
//		.concat("<bounds minlat=\"50.91695\" minlon=\"6.876383\" maxlat=\"50.935183\" maxlon=\"6.918817\" />")
		;
	
	final static String GPXCOMPACT = "\t<wpt lat=\"@@WPLAT@@\" lon=\"@@WPLON@@\">\n"
						.concat("\t\t<time>@@CACHETIME@@T00:00:00</time>\n")
						.concat("\t\t<name>@@WPNAME@@</name>\n")
						.concat("\t\t<cmt>@@WPCMT@@</cmt>\n")
						.concat("\t\t<desc>@@WPDESC@@</desc>\n")
						.concat("\t\t<url>@@WPURL@@</url>\n")
						.concat("\t\t<urlname>@@WPURLNAME@@</urlname>\n")
						.concat("\t\t<sym>@@WPSYMBOL@@</sym>\n")
						.concat("\t\t<type>@@WPTYPE@@</type>\n");
	
	final static String GPXEXTENSION ="\t\t<groundspeak:cache id=\"@@CACHEID@@\" available=\"@@CACHEAVAILABLE@@\" archived=\"@@CACHEARCHIVED\" xmlns:groundspeak=\"http://www.geocaching.com/cache/1/0\">\n"
						.concat("\t\t\t<groundspeak:name>@@CACHENAME@@</groundspeak:name>\n")
						.concat("\t\t\t<groundspeak:placed_by>@@CACHEPLACEDBY@@<groundspeak:placed_by>\n")
						.concat("\t\t\t<groundspeak:owner_id id=\"@@CACHEOWNERID@@\">@@CACHEOWNER@@</groundspeak:owner_id>\n")
						.concat("\t\t\t<groundspeak:type>@@CACHETYPE@@</groundspeak:type>\n")
						.concat("\t\t\t<groundspeak:container>@@CACHECONTAINER@@</groundspeak:container>\n")
						.concat("\t\t\t<groundspeak:difficulty>@@CACHEDIFFICULTY@@</groundspeak:difficulty>\n")
						.concat("\t\t\t<groundspeak:terrain>@@CACHETERRAIN@@</groundspeak:terrain>\n")
						.concat("\t\t\t<groundspeak:country>@@CACHECOUNTRY@@</groundspeak:country>\n")
						.concat("\t\t\t<groundspeak:state>@@CACHESTATE@@</groundspeak:state>\n")
						.concat("\t\t\t<groundspeak:short_description html=\"@@CACHEHTML@@\">@@CACHESHORTDESCRIPTION@@</groundspeak:short_description>\n")
						.concat("\t\t\t<groundspeak:long_description html=\"@@CACHEHTML@@\">@@CACHELONGDESCRIPTION@@</groundspeak:long_description>\n")
						.concat("\t\t\t<groundspeak:encoded_hints>@@CACHEHINT@@</groundspeak:encoded_hints>\n");

	final static String GPXLOG = "\t\t\t\t<groundspeak:log id=\"@@LOGID@@\">\n"
						.concat("\t\t\t\t\t<groundspeak:date>@@LOGDATE@@</groundspeak:date>\n")
						.concat("\t\t\t\t\t<groundspeak:type>@@LOGTYPE@@</groundspeak:type>\n")
						.concat("\t\t\t\t\t<groundspeak:finder id=\"@@LOGFINDERID@@\">@@LOGFINDER@@</groundspeak:finder>\n")
						.concat("\t\t\t\t\t<groundspeak:text encoded=\"@@LOGENCODE@@\">@@LOGTEXT@@</groundspeak:text>\n")
						.concat("\t\t\t\t</groundspeak:log>\n");
	
	final static String GPXTB = "\t\t\t\t<groundspeak:travelbug id=\"@@TBID@@\" ref=\"@@TBREF@@\">\n"
						.concat("\t\t\t\t\t<groundspeak:name>@@TBNAME@@</groundspeak:name>\n")
						.concat("\t\t\t\t</groundspeak:travelbug>\n");
	
	static boolean smartIds;
	static boolean customIcons;
	static boolean separateFile;
	static boolean sendToGarmin;
	static int outType;
	
	public GpxExportNg() {
		GpxExportNgForm exportOptions;
		int ret;

		exportOptions = new GpxExportNgForm();
		ret = exportOptions.execute();
		
		if (FormBase.IDCANCEL == ret) {
			return;
		}
		
		outType = exportOptions.getExportType();
		smartIds = exportOptions.getSmartIds();
		separateFile = exportOptions.getSeparateFiles();
		sendToGarmin = exportOptions.getSendToGarmin();
		customIcons = exportOptions.getCustomIcons();
		
		if (separateFile) {
			final Hashtable fileHandles;
			final String directoryName;
			//TODO: get directory
			//TODO: initialize files
			//TODO: iterate through caches
			//TODO: remove old files with prefix
			//TODO: write new files
		} else {
			final File file;
			final FileChooser fc = new FileChooser(FileChooserBase.SAVE, Global.getPref().getExportPath(expName));
			fc.setTitle("Select target GPX file:");
			fc.addMask("*.gpx");
			if(fc.execute() == FormBase.IDCANCEL) return;
			
			file = fc.getChosenFile();
			Global.getPref().setExportPath(expName, file.getPath());

			StringBuffer out = new StringBuffer();
			
			out.append(formatHeader());
			
			for(int i = 0; i<Global.getProfile().cacheDB.size(); i++){
				CacheHolder ch=Global.getProfile().cacheDB.get(i);
				if (ch.is_incomplete()) {
					Vm.debug("skipping incomplete waypoint "+ch.getWayPoint());
					continue;
				}
				out.append(formatCache(ch));
			}
			
			out.append("</gpx>\n");
			
			try {
				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(file)));
				outp.print(out.toString());
				outp.close();
			} catch (Exception ex) {
				if (Global.getPref().debug) Global.getPref().log("unable to write GPX output to "+file.toString(), ex);
				else Global.getPref().log("unable to write GPX output to "+file.toString());
				//TODO: give a message to the user
			}
			//TODO: write file. do it when we have a complete waypoint to save memory?
			Vm.debug(out.toString());
		}
	}
	
	private String formatCache(CacheHolder ch) {
		// no addis or custom in MyFindsPq - and of course only finds
		if ((GPX_MYFINDSPQ == outType) && 
				((ch.getType() == CacheType.CW_TYPE_CUSTOM) || ch.isAddiWpt() || ! ch.is_found())) 
				return "";
		
		StringBuffer ret = new StringBuffer();

		ret.append(formatCompact(ch));
		
		if (outType != GPX_COMPACT && !(ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt())) {
			ret.append(formatPqExtensions(ch));
		}
		ret.append("\t</wpt>\n");
		return ret.toString();
	}
	
	private String formatCompact(CacheHolder ch) {
		Transformer trans = new Transformer(true);
		
		trans.add(new Regex("@@WPLAT@@", 
				((ch.pos.latDec >= -90) && (ch.pos.latDec <= 90)?String.valueOf(ch.pos.latDec):"")
			));
		
		trans.add(new Regex("@@WPLON@@",
				((ch.pos.lonDec >= -180) && (ch.pos.lonDec <= 180)?String.valueOf(ch.pos.lonDec):"")
			));
		
		trans.add(new Regex("@@CACHETIME@@", ch.getDateHidden()));
		
		if (smartIds && ch.getType() != CacheType.CW_TYPE_CUSTOM) {
			if (ch.isAddiWpt()) {
				trans.add(new Regex("@@WPNAME@@",ch.mainCache.getWayPoint()
						.concat(" ")
						.concat(ch.getWayPoint().substring(0,2))));
			} else {
				trans.add(new Regex("@@WPNAME@@",ch.getWayPoint()
						.concat(" ")
						.concat(CacheType.getExportShortId(ch.getType()))
						.concat(String.valueOf(ch.getTerrain()))
						.concat(String.valueOf(ch.getHard()))
						.concat(CacheSize.getExportShortId(ch.getCacheSize()))
					));
			}
		} else {
			trans.add(new Regex("@@WPNAME@@",ch.getWayPoint()));
		}
		
		if (ch.isAddiWpt() || ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPCMT@@",ch.getFreshDetails().LongDescription));
		} else {
			trans.add(new Regex("@@WPCMT@@",""));
		}
		
		if (ch.isAddiWpt()) {
			trans.add(new Regex("@@WPDESC@@",ch.getCacheName()));
		} else {
			trans.add(new Regex("@@WPDESC@@",
					ch.getCacheName()
					.concat(" by ")
					.concat(ch.getCacheOwner())
					.concat(", ")
					.concat(CacheType.cw2ExportString(ch.getType()))
					.concat(" (")
					.concat(CacheTerrDiff.shortDT(ch.getHard()))
					.concat("/")
					.concat(CacheTerrDiff.shortDT(ch.getTerrain()))
					.concat(")")
				));
		}
		
		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPURL@@",""));
		} else {
			if (ch.isAddiWpt()) {
				//TODO: find out URL schema for additional waypoints
				//TODO: check for OC caches
				trans.add(new Regex("@@WPURL@@","http://www.geocaching.com/seek/wpt.aspx?wp=".concat(ch.getWayPoint())));
			} else {
				//TODO: check for OC caches
				trans.add(new Regex("@@WPURL@@","http://www.geocaching.com/seek/cache_details.aspx?wp=".concat(ch.getWayPoint())));
			}
		}
		
		if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
			trans.add(new Regex("@@WPURLNAME@@",""));
		} else {
			trans.add(new Regex("@@WPURLNAME@@",ch.getCacheName()));
		}
		
		if (customIcons) {
			//TODO: replace with SKGs custom symbol code
			trans.add(new Regex("@@WPSYMBOL@@","Geocache"));
		} else {
			if (ch.isAddiWpt()) {
				trans.add(new Regex("@@WPSYMBOL@@", CacheType.id2GpxString(ch.getType()).substring(CacheType.id2GpxString(ch.getType()).indexOf("|")+1)));
			} else if (ch.getType() == CacheType.CW_TYPE_CUSTOM) {
				trans.add(new Regex("@@WPSYMBOL@@", "Custom"));
			} else if (ch.is_found()) {
				trans.add(new Regex("@@WPSYMBOL@@","Geocache found"));
			} else {
				trans.add(new Regex("@@WPSYMBOL@@","Geocache"));
			}
		}
		
		trans.add(new Regex("@@WPTYPE@@",CacheType.id2GpxString(ch.getType())));
		
		return trans.replaceFirst(GPXCOMPACT);
	}
	
	private String formatPqExtensions(CacheHolder ch) {
		// no details pq details for addis or custom waypoints
		if (ch.getType() == CacheType.CW_TYPE_CUSTOM || ch.isAddiWpt()) return "";
		
		StringBuffer ret = new StringBuffer();
		Transformer trans = new Transformer(true);
		ch.getFreshDetails();
		trans.add(new Regex("@@CACHEID@@",ch.GetCacheID()));
		trans.add(new Regex("@@CACHEAVAILABLE@@",ch.is_available()?TRUE:FALSE));
		trans.add(new Regex("@@CACHEARCHIVED",ch.is_archived()?TRUE:FALSE));
		trans.add(new Regex("@@CACHENAME@@",ch.getCacheName()));
		trans.add(new Regex("@@CACHEPLACEDBY@@",ch.getCacheOwner()));
		trans.add(new Regex("@@CACHEOWNERID@@","31415"));
		trans.add(new Regex("@@CACHEOWNER@@",ch.getCacheOwner()));
		trans.add(new Regex("@@CACHETYPE@@",CacheType.id2GpxString(ch.getType())));
		trans.add(new Regex("@@CACHECONTAINER@@",CacheSize.cw2ExportString(ch.getCacheSize())));
		trans.add(new Regex("@@CACHEDIFFICULTY@@",CacheTerrDiff.shortDT(ch.getHard())));
		trans.add(new Regex("@@CACHETERRAIN@@",CacheTerrDiff.shortDT(ch.getTerrain())));
		trans.add(new Regex("@@CACHECOUNTRY@@",ch.details.Country));
		trans.add(new Regex("@@CACHESTATE@@",ch.details.State));
		trans.add(new Regex("@@CACHEHTML@@",ch.is_HTML()?TRUE:FALSE));
		trans.add(new Regex("@@CACHESHORTDESCRIPTION@@","CacheWolf can not provide Short description"));
		/* 
		 * TODO: add additional waypoints to long description, but then GPX importer must 
		 * remove them as well. otherwise people using PQs to feed CacheWolf will have 
		 * duplicate additionals at end of PQ like export 
		 */
		trans.add(new Regex("@@CACHELONGDESCRIPTION@@",ch.details.LongDescription));
		trans.add(new Regex("@@CACHEHINT@@",ch.details.Hints));
		
		ret.append(trans.replaceAll(GPXEXTENSION));
		
//		ret.append("\t\t\t<groundspeak:logs>\n");
//		ret.append(formatLogs(ch));
//		ret.append("\t\t\t</groundspeak:logs>\n");
//		
//		ret.append("\t\t\t<groundspeak:travelbugs>\n");
//		ret.append(formatTbs(ch));
//		ret.append("\t\t\t</groundspeak:travelbugs>\n");
		
		ret.append("\t\t</groundspeak:cache>\n");
		return ret.toString();
	}
	
	public void doit() {
		
	}
	
	public String formatTbs(CacheHolder ch) {
		Transformer trans = new Transformer(true);
		return "";
//		return trans.replaceFirst(GPXTB);
	}
	
	public String formatLogs(CacheHolder ch) {
		Transformer trans = new Transformer(true);
		return "";
//		return trans.replaceFirst(GPXLOG);
	}
	
	public String formatHeader() {
		Transformer trans = new Transformer(true);
		trans.add(new Regex("@@CREATEDATE@@",new Date().setFormat("yyyy-MM-dd").toString()));
		return trans.replaceFirst(GPXHEADER);
	}
}
